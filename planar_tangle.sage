#####################################################################################################
#                                                                                                   #
#   What we need here is a list of TL algebras, eg obtained with                                    #
#       T = [TemperleyLiebAlgebra(i, q, R) for i in range(7)]                                       #
#   over the ring                                                                                   #
#       R.<a1,a2,b1,b2,q,iSymbol> = LaurentPolynomialRing(QQbar)                                    #
#                                                                                                   #
#   It could happen that older versions of sage cannot build such rings of Laurent polynomials.     #
#   In that case you simply remove the "Laurent" and build a standard polynomial ring.              #
#                                                                                                   #
#   The code in this file works like this.                                                          #        
#                                                                                                   #    
#       (*) The function F is an implementation of the tangle $\widetilde{}_n$, as follows: It      #
#           takes two arguments, the first being an arbitrary tangle, while the second must be      #
#           a 2-tangle.                                                                             #    
#                                                                                                   #        
#       (*) The function recursionF takes two inputs, a 2-tangle v and a number n. This is the      #            
#           actual implementation of the recursive definition of $\widetilde{}_n$: The output is    #
#           the n-tangle $\widetilde{v}_n$                                                          # 
#                                                                                                   # 
#       (*) getVector takes the list generated by F as input and returns the vector it corrseponds  # 
#           to, in the correct TL-algebra                                                           #
#                                                                                                   #
#       (*) To leftInclusion we pass a vector and a number n , which is greater than the order of   #
#           the TL algebra (lets say the order is k) the vector lives in. The output is the result  #
#           of passing the vector to left inclusion tangle $inc_k^n$. That is, it is not only the   #
#           inclusion into the TL algebra one order higher, but arbitrarily often.                  #
#                                                                                                   # 
#####################################################################################################

######################################################
##  The ultimate goal would be to have a function   ##
##  that recursively constructs the perfect tangle  ##
##  B_n. Seems doable.                              ##
######################################################

# def init_R():
#     R.<a1,a2,b1,b2,q,iSymbol> = LaurentPolynomialRing(QQbar)
#     return R

def init_FF(tang, n):
    FF = [0,0,tang]
    for i in range(3,n):
        FF.append(F(FF[i-1], tang))
    return FF

def get_variable(i):
    return "v"+str(i)

def recursionF(v, n):
    if n == 3:
        return F(v,v)
    else:
        return F(
                recursionF(v, n-1),
                v)

def F( v, w ):
    this_TL = v.parent()
    subs_dict = {}

    for i in range(this_TL.order()+1):
        vTEMP = var(get_variable(i+1))
        subs_dict.update({vTEMP : i+1})

    vTerms = v.terms()
    wTerms = w.terms()
    vSplit = [[t.trailing_coefficient(), t.diagram().standard_form()] for t in vTerms]
    wSplit = [[t.trailing_coefficient(), t.diagram().standard_form()] for t in wTerms]
    
    answer = []
    for x in vSplit:
        vector = x[1]
        for comp in vector:
            for i in range(1,this_TL.order()+1):
                if -i in comp:
                    comp.remove(-i)
                    comp.append(-eval(get_variable(i+1)))
                if i in comp:
                    if i != 1:
                        comp.remove(i)
                        comp.append(eval(get_variable(i+1)))


    for x in wSplit:
        vector = x[1]
        for comp in vector:
            for i in range(1,3):
                if -i in comp:
                    if i != 2:
                        comp.remove(-i)
                        comp.append(-eval(get_variable(i)))
                if i in comp:
                    comp.remove(i)
                    comp.append(eval(get_variable(i)))
    
    for x in vSplit:
        xCoeff = x[0]
        xVec = x[1]
        for y in wSplit:
            yCoeff = y[0]
            yVec = y[1]
            appendThis = [xCoeff*yCoeff, []]
            for xComp in xVec:
                for yComp in yVec:
                    if 1 not in xComp and -2 not in yComp:
                        if xComp not in appendThis[1]:
                            appendThis[1].append(xComp)
                        if yComp not in appendThis[1]:
                            appendThis[1].append(yComp)
                    if 1 in xComp and -2 in yComp:
                        yTemp = copy(yComp)
                        xTemp = copy(xComp)
                        yTemp.remove(-2)
                        xTemp.remove(1)
                        xTemp.append(yTemp[0])
                        if xTemp not in appendThis[1]:
                            appendThis[1].append(xTemp)

            answer.append(appendThis)

    for x in answer:
        for y in x[1]:
            try:
                y[0] = y[0].subs(subs_dict)
            except:
                pass
            try:
                y[1] = y[1].subs(subs_dict)
            except:
                pass
            y.sort()
        x[1].sort()

    answer = getVector(answer)
    return answer


def leftInclusion(v, topDim):
    vTerms = v.terms()
    split = [ [x.trailing_coefficient(), BASIS_leftInclusion(x.trailing_monomial(), topDim)] for x in vTerms ]
    split = getVector(split)
    return split


def BASIS_leftInclusion(basis_element, topDim):
    diagram = basis_element.diagram().standard_form()
    dim = len(diagram)
    for i in range(1,topDim - dim+1):
        diagram.append([-(dim+i), dim+i])
    diagram.sort()
    return diagram

def getVector(splitList):
    TL_algebra = T[ len(splitList[0][1]) ]
    _basis = TL_algebra.basis().list()
    _base_ring = TL_algebra.base_ring()
    summed = TL_algebra.zero()
    for x in splitList:
        _coeff = _base_ring(x[0])
        vector = [v for v in _basis if v.diagram().standard_form() == x[1]]
        summed += _coeff*vector[0]
    summed = reduceIsquared(summed)
    return summed
