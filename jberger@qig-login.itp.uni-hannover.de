from itertools import chain
# var("iSymbol")
bas = T.basis().list()

## CONVERT base diagram TO LIST; NEEDED FOR COMPARISON

def convertToList( diagram ):
    tempList = []
    for i in range(len(diagram)):
        tempList.append([])
        tempList[i] = [ x for x in diagram[i] ]
    [x.sort() for x in tempList]
    tempList.sort()
    return tempList

uni = [[-i,i] for i in range(1,T.order()+1)]
[x.sort() for x in uni]
uni.sort()
unit = [ u for u in bas if uni == convertToList(u.diagram()) ][0]

#### RETURN THE ADJOINT OF A TANGLE

def adjoint(tangle):
    tList = convertToList(tangle.diagram())
    tempList = []
    for i in range(T.order()):
        tempList.append([-tList[i][0], -tList[i][1]])
    [x.sort() for x in tempList]
    tempList.sort()
    return [x for x in bas if convertToList(x.diagram()) == tempList][0]


### ROTATE AN INPUT TANGLE ONE CLICK WRT THE SPECIFIED ORIENTATION: 1 <=> CCW, -1 <=> CW. We can use the fact that (rot T)^* = rot^-1 T^*

def rotateTangle( vector_in, orientation ):
    basis_as_list = [ convertToList(x.diagram()) for x in bas ]
    strands = len(basis_as_list[0])
    in_index = bas.index(vector_in)
    in_list = basis_as_list[in_index]
    out_list = []

    for i in range(strands):
        out_list.append([])
        for x in in_list[i]:
            if x == -1:
                out_list[i].append( 1 )
            elif x == strands:
                out_list[i].append( -strands )
            else:
                out_list[i].append( x + 1 )
    
    [x.sort() for x in out_list]
    out_list.sort()
    rotated = bas[ basis_as_list.index( out_list ) ]
    return (rotated if orientation == 1 else adjoint(rotated))

### GIVEN A LIST OF COEFFICIENTS AND AN ORIENTATION, COMPUTE ALL ROTATIONS

def allRotations(coeffs, orientation):
    vectors = [x for x in bas]
    number_of_rotations = 0
    rotations = []
    
    while number_of_rotations < 2*T.order():
        appendThis = sum(coeffs[k]*vectors[k] for k in range(len(bas)))
        if number_of_rotations == 1 and rotations[0] == appendThis:
            break
        rotations.append(appendThis)
        for j in range(len(vectors)):
            vectors[j] = rotateTangle(vectors[j], orientation)
        number_of_rotations += 1
    return rotations

### MULTIPLY TANGLES WITH ADJOINT TANGLES; REMOVE REDUNDANT EQUATIONS

def allMultiplications(rot, rotCC):
    answer = []
    for i in range(len(rot)):
        prodTerms = (rot[i]*rotCC[i]).terms()
        answer.append( 
            [x.coefficients()[0] for x in prodTerms
                if x.trailing_monomial() != unit]
            )
        if len(answer[i]) != len(prodTerms) - 1:
            print "failure"
            return

    answerTemp = list(chain.from_iterable(answer))
    answer = []

    for i in range(len(answerTemp)):
        if answerTemp[i] == 0:
            continue
        else:
            answer.append(answerTemp[i])
        for j in range(i+1,len(answerTemp)):
            if answerTemp[j] == 0:
                continue
            if expand(answerTemp[i] - answerTemp[j]) == 0:
                answerTemp[j] = 0
    return answer

### TURN THE OBTAINED EQUATIONS, WHICH LIVE IN A RING OF LAURENT POLYNOMIALS, INTO SYMBOLIC EQUATIONS WHICH SAGE CAN SOLVE

def getSymbolicEquations(symbolizeThis, dictTranslate):
    returnThis = []
    for x in symbolizeThis:
        equa = \
            expand(
                x.subs(dictTranslate
                ).subs(dictTranslate)
            ).subs({iSymbol^2 : -1})
        imagPart, realPart = equa.maxima_methods().divide(iSymbol)
        if realPart != 0:
            returnThis.append( realPart )
        if imagPart != 0:
            returnThis.append( imagPart )
    return returnThis

### DECOMPOSE THE SET OF BASIS TANGLES INTO SETS CLOSED UNDER ROTATION
# This is useful if you want to compute 
#   (a) rotation invariant tangles
#   (b) n-tangles that are eigenvectors of rotation with eigenvalue an n-th root of unity
# Note that case (b) only makes sense for components of the decomposition of size 2n. As an example: Case (b) can not be found in TL_3, because the decomposition
# consists of a two and a three element set. In TL_4, however, there is a set with 8 = 2*4 elements, which might define a perfect tangle satisfying (b). Unfortunately, the identity is not obtained by multiplication of such tangles, hence: there is no such thing in TL_4

def rotationInvariantDecomposition():
    decomp = []
    indices = range(len(bas))
    component = 0
    while indices:
        decomp.append([])
        i = indices[0]
        while i not in decomp[component]:
            decomp[component].append(i)
            indices.remove(i)
            i = bas.index( rotateTangle(bas[i],1))
        component += 1
    return decomp

### To this function one supplies a dictionary, and the two rotation arrays. It then simply substitutes the words from the dictionary, and returns the output of 
# allMultiplications, i.e. an array, which - if the dictionary specifies a solution - should only consist of zeroes;

def checkSolution( dict_in, rot_in, rotCC_in ):
    rot_out = []
    rotCC_out = []

    for i in range(len(rot_in)):
        rot_terms = rot_in[i].terms()
        rotCC_terms = rotCC_in[i].terms()
        
        appendThis = sum(k for k in [x.trailing_coefficient().subs(dict_in)*x.trailing_monomial() for x in rot_terms])
        appendThisCC = sum(k for k in [x.trailing_coefficient().subs(dict_in)*x.trailing_monomial() for x in rotCC_terms])
        
        rot_out.append(appendThis)
        rotCC_out.append(appendThisCC)

    answerSolution = allMultiplications(rot_out, rotCC_out)
    answerSolution = [expand(x.subs(dict_in)) for x in answerSolution]
    
    return answerSolution
